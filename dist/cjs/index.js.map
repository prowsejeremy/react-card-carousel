{"version":3,"file":"index.js","sources":["../../node_modules/tslib/tslib.es6.js","../../src/components/arrowButtons.tsx","../../src/components/pagination.tsx","../../node_modules/style-inject/dist/style-inject.es.js","../../src/index.tsx","../../src/helpers.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","import React from \"react\";\nimport { ArrowPropsInterface } from \"../types.ts\";\n\nconst ArrowButtons = (props: ArrowPropsInterface) => {\n  const { nextArrow, prevArrow, currentIndex, itemCount, prevCard, nextCard } =\n    props;\n\n  return (\n    <>\n      <button\n        className={`cardCarousel-arrow prev-button ${currentIndex === 0 ? \"disabled\" : \"active\"\n          }`}\n        onClick={prevCard}\n      >\n        <>{prevArrow || <span className=\"cardCarousel-arrow-inner\" />}</>\n      </button>\n\n      <button\n        className={`cardCarousel-arrow next-button ${currentIndex === itemCount ? \"disabled\" : \"active\"\n          }`}\n        onClick={nextCard}\n      >\n        <>{nextArrow || <span className=\"cardCarousel-arrow-inner\" />}</>\n      </button>\n    </>\n  );\n};\n\nexport default ArrowButtons;\n","import React from \"react\";\nimport { PaginationPropsInterface } from \"../types.ts\";\n\nconst Pagination = (props: PaginationPropsInterface) => {\n  const { itemCount, currentIndex, goToCard } = props;\n\n  const paginationItems = [];\n\n  for (let index = 0; index <= itemCount; index++) {\n    paginationItems.push(\n      <button\n        key={index}\n        onClick={() => goToCard(index)}\n        className={`cardCarousel-pagination-button ${currentIndex === index ? \"active\" : \"\"\n          }`}\n      />\n    );\n  }\n\n  return <div className=\"cardCarousel-pagination\">{paginationItems}</div>;\n};\n\nexport default Pagination;\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import {\n  SettingsInterface,\n  PropsInterface,\n  ImperitiveHandleInterface,\n} from \"./types.ts\";\n\nimport React, {\n  forwardRef,\n  useState,\n  useEffect,\n  useRef,\n  useImperativeHandle,\n  useMemo,\n} from \"react\";\n\nimport ArrowButtons from \"./components/arrowButtons.tsx\";\nimport Pagination from \"./components/pagination.tsx\";\n\nimport { getCenterMoveVal, getMoveVal } from \"./helpers.ts\";\n\nimport \"./styles.scss\";\n\nconst CardCarousel = forwardRef<ImperitiveHandleInterface, PropsInterface>(\n  (props, carouselRef): React.JSX.Element => {\n    const { children, settings } = props;\n\n    const defaultSettings: SettingsInterface = {\n      // Presentation settings\n      gap: 20, // gap size between each card/silde (px)\n      padding: 50, // padding either side of the viewbox.\n      cardsToShow: 0, // Defines the width of each card, if set to 0 the width will be inherited from the each cards children\n      transitionSpeed: 300, // speed for transitions (ms)\n\n      // Control settings\n      centerMode: false,\n      yieldToImages: false,\n      pagination: false,\n      touchControls: true,\n      arrows: true, // enable or disable arrows\n      nextArrow: null, // provide custom markup for the next button\n      prevArrow: null, // provide custom markup for the prev button\n\n      // Events\n      beforeChange: null, // fires just before change\n      afterChange: null, // fires just after change\n      onTouchStart: null, // fires just after touch start\n      onTouchMove: null, // fires just after touch move\n      onTouchEnd: null, // fires just after touch end\n    };\n\n    const [config, setConfig] = useState<SettingsInterface>({\n      ...defaultSettings,\n      ...settings,\n    });\n\n    // State\n    const [touchX, setTouchX] = useState<number>(0);\n    const [itemsContained, setItemsContained] = useState<boolean>(true); // Are the items contained within the items wrapper?\n    const [itemWidth, setItemWidth] = useState<number>(0);\n    const [isResizing, setIsResizing] = useState<boolean>(false);\n    const [itemsWrapperWidth, setItemsWrapperWidth] = useState<number>(0);\n    const [currentIndex, setCurrentIndex] = useState<number>(0);\n    const [itemCount, setItemCount] = useState<number>(0);\n    const [imagesLoaded, setImagesLoaded] = useState<boolean>(false);\n    const [animateTransition, setAnimateTransition] = useState<boolean>(false);\n    const [scrolling, setScrolling] = useState<boolean>(false);\n    const [swiping, setSwiping] = useState<boolean>(false);\n\n    // Refs\n    const resizeTimer = useRef<number | null>(null);\n    const previousWindowWidth = useRef<number>(0);\n    const carouselItemsRef = useRef<HTMLDivElement | null>(null);\n    const carouselWrapperRef = useRef<HTMLDivElement | null>(null);\n    const offsetRef = useRef<number>(0);\n\n    useMemo(() => {\n      setConfig({\n        ...defaultSettings,\n        ...settings,\n      });\n    }, [settings]);\n\n    useEffect(() => {\n      if (!children?.length) return;\n      if (itemCount !== children.length - 1) {\n        setItemCount(children.length - 1);\n      }\n    }, [children]);\n\n    // Animate to item\n    useEffect(() => {\n      if (animateTransition) {\n        scrub(`${offsetRef.current}px`);\n        setTimeout(() => {\n          setAnimateTransition(false);\n        }, config.transitionSpeed);\n      }\n    }, [animateTransition, config.transitionSpeed]);\n\n    // Set inital width for the carousel items\n    useEffect(() => {\n      if (itemCount !== 0 && itemsWrapperWidth === 0) {\n        getItemsWrapperWidth();\n      }\n    }, [carouselItemsRef.current, itemCount]);\n\n    // Run checks to reposition the carousel items on width change\n    useEffect(() => {\n      !isResizing && itemsWrapperWidth !== 0 && updateCarouselPosition();\n    }, [isResizing, itemsWrapperWidth]);\n\n    // Run checks to resize and reposition the carousel on config changes,\n    // or if the individual item width changes\n    useEffect(() => {\n      getItemsWrapperWidth();\n      updateCarouselPosition();\n    }, [\n      // Config change\n      itemCount,\n      config.gap,\n      config.padding,\n      config.centerMode,\n      config.yieldToImages,\n      // Item width change\n      itemWidth,\n    ]);\n\n    useEffect(() => {\n      getItemWidth();\n    }, [config.cardsToShow]);\n\n    // Set inital width for each card, if applicable\n    useEffect(() => {\n      if (config.cardsToShow !== 0 && itemWidth === 0) {\n        getItemWidth();\n      }\n    }, [carouselWrapperRef.current]);\n\n    // Add window resize listener\n    useEffect(() => {\n      window.addEventListener(\"resize\", handleResize);\n      previousWindowWidth.current = window.innerWidth;\n\n      return () => {\n        window.removeEventListener(\"resize\", handleResize);\n      };\n    }, [typeof window !== undefined, imagesLoaded, itemCount]);\n\n    // Handle resize of browser window\n    const handleResize = () => {\n      clearTimeout(resizeTimer.current);\n      // Only handle resize if the width has changed, we don't care about the height.\n      // Mainly a fix for iOS Safari and mobile browsers which change browser height on scroll.\n      // Lock the width, height and position of certain elements to ensure resizing doesn't\n      // mess with the page layout.\n      if (window.innerWidth !== previousWindowWidth.current) {\n        const currentCarouselWrapper =\n          carouselWrapperRef.current.getBoundingClientRect();\n        carouselWrapperRef.current.style.width = `${currentCarouselWrapper.width}px`;\n        carouselWrapperRef.current.style.height = `${currentCarouselWrapper.height}px`;\n        carouselItemsRef.current.style.position = \"absolute\";\n        setItemsWrapperWidth(99999);\n        setIsResizing(true);\n        previousWindowWidth.current = window.innerWidth;\n\n        // Reset everything once resizing has finished.\n        resizeTimer.current = setTimeout(() => {\n          carouselItemsRef.current.style.removeProperty(\"position\");\n          carouselWrapperRef.current.style.removeProperty(\"width\");\n          carouselWrapperRef.current.style.removeProperty(\"height\");\n          setIsResizing(false);\n          getItemWidth();\n          getItemsWrapperWidth();\n          resizeTimer.current = null;\n        }, 500);\n      }\n    };\n\n    // /////////////////////////////////\n    // WIP - Tidy up reset on resize\n    // /////////////////////////////////\n\n    const updateCarouselPosition = () => {\n      const itemsBox = carouselItemsRef.current?.getBoundingClientRect();\n      const wrapperBox = carouselWrapperRef.current?.getBoundingClientRect();\n\n      // Only enable controls if the items container is larger than the wrapper.\n      setItemsContained(itemsBox?.width <= wrapperBox?.width);\n      snapToItem(0);\n    };\n\n    useEffect(() => {\n      itemsContained && scrub(0);\n    }, [itemsContained]);\n\n    // If cardsToShow has been set, calculate the width of each item based on the viewBox size.\n    const getItemWidth = () => {\n      const wrapperBox = carouselWrapperRef.current?.getBoundingClientRect();\n\n      if (config.cardsToShow !== 0 && carouselWrapperRef.current) {\n        setItemWidth(wrapperBox.width / config.cardsToShow);\n      }\n    };\n\n    // Check for the presense of images in the card content,\n    // wait for them to load before calculating width of cards.\n    const checkIfCardImagesLoaded = (element: Element) => {\n      const hasImages = element.querySelectorAll(\"img\");\n\n      if (!hasImages || typeof hasImages !== \"object\")\n        return Promise.resolve(true);\n\n      return Promise.all(\n        Array.from(hasImages).map((img) => {\n          return new Promise((resolve) => {\n            if (img.complete) resolve(1);\n            img.onload = img.onerror = resolve;\n          });\n        })\n      );\n    };\n\n    // Get the inital wrapper width based on the width of all children with their associated padding values\n    const getItemsWrapperWidth = () => {\n      if (!carouselItemsRef.current) return;\n\n      const carouselChildren = carouselItemsRef.current.children;\n      const paddingWidth = config.gap * itemCount;\n\n      if (carouselChildren) {\n        let carouselWidth = 0;\n\n        const processWidth = (child: any) => {\n          const firstChild = child.children[0];\n          const childWidth = firstChild?.offsetWidth;\n          carouselWidth += config.cardsToShow > 0 ? itemWidth : childWidth;\n        };\n\n        if (config.yieldToImages && !imagesLoaded) {\n          Promise.all(\n            Array.from(carouselChildren).map((child: HTMLElement) =>\n              checkIfCardImagesLoaded(child).then(() => {\n                processWidth(child);\n              })\n            )\n          ).then(() => {\n            setImagesLoaded(true);\n            setItemsWrapperWidth(carouselWidth + paddingWidth);\n          });\n        } else {\n          Array.from(carouselChildren).map((child: any) => {\n            processWidth(child);\n          });\n          setItemsWrapperWidth(carouselWidth + paddingWidth);\n        }\n      }\n    };\n\n    const snapToItem = async (index: number) => {\n      let newOffset = 0;\n\n      // Check if we are at the start of the list and haven't changed index,\n      // if so just center to 0 and return.\n      if (currentIndex === index && currentIndex === 0 && !config.centerMode) {\n        offsetRef.current = newOffset;\n        setAnimateTransition(true);\n        return;\n      }\n\n      const dir = index >= currentIndex ? \"next\" : \"prev\";\n      const targetItem = carouselItemsRef.current.children.item(index);\n\n      if (!targetItem) return;\n\n      const wrapperBox = carouselWrapperRef.current?.getBoundingClientRect();\n\n      // trigger beforeChange listener\n      config.beforeChange &&\n        currentIndex !== index &&\n        config.beforeChange(currentIndex, index);\n\n      if (config.centerMode) {\n        // Get move calculation for centerMode\n        newOffset = await getCenterMoveVal(targetItem, wrapperBox);\n      } else {\n        // Get move calculation where not centerMode\n        const { moveVal, atStart, atEnd } = await getMoveVal(\n          targetItem,\n          carouselItemsRef.current,\n          wrapperBox,\n          dir\n        );\n\n        newOffset = moveVal;\n        // Update offset.\n        if (atStart) {\n          index = 0;\n        } else if (atEnd) {\n          index = itemCount;\n        }\n      }\n\n      offsetRef.current = newOffset;\n      setAnimateTransition(true);\n      setCurrentIndex(index);\n\n      config.afterChange && currentIndex !== index && config.afterChange(index);\n    };\n\n    // //////////////////////////////////////////////////////¿\n    // Touch Controls\n    // //////////////////////////////////////////////////////¿\n\n    const handleTouchStart = (e) => {\n      if (!config.touchControls || scrolling) return;\n      const _touchX = e.x ?? e?.changedTouches[0]?.clientX; // desktop event props ?? mobile (touch) event props\n      setTouchX(_touchX);\n      config.onTouchStart && config.onTouchStart(_touchX);\n    };\n\n    const handleTouchMove = (e) => {\n      if (!config.touchControls || scrolling) return;\n      const _eX = e.x ?? e?.changedTouches[0]?.clientX; // desktop event props ?? mobile (touch) event props\n      const _touchDelta = _eX - touchX;\n      config.onTouchMove && config.onTouchMove(_touchDelta);\n\n      // If the user has interacted with the carousel, set swiping to true\n      if (Math.abs(_touchDelta) > 5) {\n        setSwiping(true);\n      }\n\n      scrub(`${offsetRef.current + _touchDelta * 1.25}px`);\n    };\n\n    const handleTouchEnd = () => {\n      // Release the scroll back to the body and remove swiping state\n      setScrolling(false);\n      setSwiping(false);\n\n      if (!config.touchControls) return;\n      config.onTouchEnd && config.onTouchEnd();\n      checkActiveItem();\n    };\n\n    // Window touch listeners to disable scroll if user\n    // interacts with the carousel\n    let winTSY = 0;\n\n    const winTSListener = (e) => {\n      winTSY = e?.changedTouches[0]?.clientY;\n    };\n\n    const winTMListener = (e) => {\n      if (swiping) {\n        e.preventDefault();\n        return false;\n      }\n\n      const winTMY = e?.changedTouches[0]?.clientY;\n      if (Math.abs(winTSY - winTMY) > 5) {\n        setScrolling(true);\n      }\n    };\n\n    const winTEListener = (e) => {\n      setScrolling(false);\n      setSwiping(false);\n    };\n\n    // Bind/unBind touch events to window\n    useEffect(() => {\n      window.addEventListener(\"touchstart\", winTSListener);\n      window.addEventListener(\"touchmove\", winTMListener, { passive: false });\n      window.addEventListener(\"touchend\", winTEListener);\n      return () => {\n        window.removeEventListener(\"touchstart\", winTSListener);\n        window.removeEventListener(\"touchmove\", winTMListener);\n        window.removeEventListener(\"touchend\", winTEListener);\n      };\n    }, [swiping]);\n\n    // Handle move transform\n    const scrub = (val) => {\n      if (itemsContained || resizeTimer.current !== null) val = 0;\n      carouselItemsRef.current.style.transform = `translateX(${val})`;\n    };\n\n    // Check which item is currently front and center\n    const checkActiveItem = (callback?) => {\n      const wrapperBox = carouselWrapperRef.current?.getBoundingClientRect();\n      const scrollItems = carouselItemsRef.current.children;\n      const centerPoint = wrapperBox.width / 2;\n      const centerPointBuffer = config.gap / 2;\n\n      // Itterate over each child and check it's position\n      Array.from(scrollItems).map((child, index) => {\n        const childRect = child.getBoundingClientRect();\n\n        // If the childs left bounds are less than the center point and right bounds are greater than\n        // the center point, we've found our star!\n        if (\n          (childRect.left - wrapperBox.left - centerPointBuffer <=\n            centerPoint &&\n            childRect.right - wrapperBox.left + centerPointBuffer >=\n            centerPoint) ||\n          (childRect.left > centerPoint && 0 === index) || // check for first item\n          (childRect.right < centerPoint && itemCount === index) // check for last item\n        ) {\n          snapToItem(index);\n          callback && callback(index);\n        }\n      });\n    };\n\n    // Generic movement function called by next / prev movement interactions.\n    const handleMoveInteract = (dir) => {\n      let changedIndex = 0;\n\n      if (dir === \"next\") {\n        changedIndex =\n          currentIndex + 1 < itemCount ? currentIndex + 1 : itemCount;\n      } else {\n        changedIndex = currentIndex - 1 > 0 ? currentIndex - 1 : 0;\n      }\n\n      return snapToItem(changedIndex);\n    };\n\n    // //////////////////////////////////////////////////////¿\n    // Interaction functions\n    // //////////////////////////////////////////////////////¿\n\n    const nextCard = () => handleMoveInteract(\"next\");\n    const prevCard = () => handleMoveInteract(\"prev\");\n\n    const goToCard = (index) => {\n      if (!carouselItemsRef.current || !carouselWrapperRef.current) return;\n      snapToItem(index);\n    };\n\n    // Pass functions to external\n    useImperativeHandle(carouselRef, () => ({\n      nextCard,\n      prevCard,\n      goToCard: (index) => goToCard(index),\n      getCurrentIndex: () => {\n        return currentIndex;\n      },\n    }));\n\n    if (!children?.length || children?.length < 1) return null;\n\n    // //////////////////////////////////////////////////////¿\n    // Main Carousel markup\n    // //////////////////////////////////////////////////////¿\n\n    return (\n      <div\n        className={`cardCarousel ${isResizing ? \"resizing\" : \"\"} ${itemsWrapperWidth !== 0 ? \"show\" : \"\"\n          }`}\n        style={{ padding: `0 ${config.padding}px` }}\n      >\n        <div\n          className=\"cardCarousel-inner\"\n          ref={carouselWrapperRef}\n          onTouchStart={handleTouchStart}\n          onTouchMove={handleTouchMove}\n          onTouchEnd={handleTouchEnd}\n        >\n          <div\n            ref={carouselItemsRef}\n            className={`cardCarousel-items ${config.centerMode ? \"itemsContained\" : \"\"\n              }`}\n            style={{\n              display: \"flex\", // Here as a placeholder value so that rendering is correct if a delay in loading styles occurs\n              alignItems: \"center\", // Here as a placeholder value so that rendering is correct if a delay in loading styles occurs\n              width:\n                itemsWrapperWidth !== 0 ? `${itemsWrapperWidth}px` : \"99999px\",\n              gap: `${config.gap}px`,\n              transition: animateTransition\n                ? `transform ease-in-out ${config.transitionSpeed}ms`\n                : \"\",\n            }}\n          >\n            {children?.map((child, key) => {\n              return (\n                <div\n                  key={key}\n                  className=\"cardCarousel-item-content\"\n                  data-active={key === currentIndex}\n                  style={itemWidth ? { width: `${itemWidth}px` } : {}}\n                >\n                  {child}\n                </div>\n              );\n            })}\n          </div>\n        </div>\n\n        {!itemsContained && (\n          <>\n            {config.pagination && (\n              <Pagination\n                currentIndex={currentIndex}\n                itemCount={itemCount}\n                goToCard={goToCard}\n              />\n            )}\n\n            {config.arrows && (\n              <ArrowButtons\n                nextArrow={config.nextArrow}\n                prevArrow={config.prevArrow}\n                currentIndex={currentIndex}\n                prevCard={prevCard}\n                itemCount={itemCount}\n                nextCard={nextCard}\n              />\n            )}\n          </>\n        )}\n      </div>\n    );\n  }\n);\n\nexport default CardCarousel;\n","// Types\nimport { getMoveValReturnObj } from \"./types\";\n\n// ////////////////////////////////////////////////////////////////////////\n// Legacy, however keeping in case it is resurrected in a future build\n// ////////////////////////////////////////////////////////////////////////\n// // Is the current item in view, checking the left and right borders of an item relative to the viewbox\n// export const itemInView = (currentItemBox:DOMRect, viewBox:DOMRect, buffer:number=0): boolean => {\n//   if (!currentItemBox || !viewBox) return\n//   return (currentItemBox.left > (viewBox.left - buffer)) && (currentItemBox.right < (viewBox.right + buffer))\n// }\n\n// ////////////////////////////////////////////////////////////////////////\n// Get value of how far to move, and if the start/end have been reached\n// ////////////////////////////////////////////////////////////////////////\n\nexport const getMoveVal = (\n  item: Element,\n  itemsWrapper: Element,\n  viewBox: DOMRect,\n  dir: string = \"next\"\n): getMoveValReturnObj => {\n  if (\n    !item ||\n    !(item instanceof HTMLElement) ||\n    !(itemsWrapper instanceof HTMLElement) ||\n    !viewBox\n  )\n    return;\n\n  const itemsBox = itemsWrapper.getBoundingClientRect();\n\n  const maxLeft = 0;\n  const maxRight = (itemsBox.width - viewBox.width) * -1;\n\n  const returnObj = {\n    moveVal: 0,\n    atStart: false,\n    atEnd: false,\n  };\n\n  if (dir === \"next\") {\n    returnObj.moveVal = item.offsetLeft * -1;\n\n    if (itemsBox.width - item.offsetLeft <= viewBox.width) {\n      returnObj.moveVal = maxRight;\n      returnObj.atEnd = true;\n    }\n  }\n\n  if (dir === \"prev\") {\n    returnObj.moveVal =\n      (item.offsetLeft - viewBox.width + item.offsetWidth) * -1;\n\n    if ((item.offsetLeft - viewBox.width + item.offsetWidth) * -1 >= 0) {\n      returnObj.moveVal = maxLeft;\n      returnObj.atStart = true;\n    }\n  }\n\n  return returnObj;\n};\n\n// ////////////////////////////////////////////////////////////////////////\n// Get distance to move when items are set to centerMode\n// ////////////////////////////////////////////////////////////////////////\n\nexport const getCenterMoveVal = (item: Element, viewBox: DOMRect): number => {\n  if (!item || !(item instanceof HTMLElement) || !viewBox) return;\n\n  const centerPoint = viewBox.width * 0.5;\n  const itemCenterPoint = item.offsetLeft + item.offsetWidth * 0.5;\n\n  return centerPoint - itemCenterPoint;\n};\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","SuppressedError","ArrowButtons","props","nextArrow","prevArrow","currentIndex","itemCount","prevCard","nextCard","React","createElement","Fragment","className","onClick","Pagination","goToCard","paginationItems","index","push","key","css","ref","insertAt","document","head","getElementsByTagName","style","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","CardCarousel","forwardRef","carouselRef","children","settings","defaultSettings","gap","padding","cardsToShow","transitionSpeed","centerMode","yieldToImages","pagination","touchControls","arrows","beforeChange","afterChange","onTouchStart","onTouchMove","onTouchEnd","config","setConfig","useState","Object","assign","touchX","setTouchX","itemsContained","setItemsContained","itemWidth","setItemWidth","isResizing","setIsResizing","itemsWrapperWidth","setItemsWrapperWidth","setCurrentIndex","setItemCount","imagesLoaded","setImagesLoaded","animateTransition","setAnimateTransition","scrolling","setScrolling","swiping","setSwiping","resizeTimer","useRef","previousWindowWidth","carouselItemsRef","carouselWrapperRef","offsetRef","useMemo","useEffect","length","scrub","current","setTimeout","getItemsWrapperWidth","updateCarouselPosition","getItemWidth","window","addEventListener","handleResize","innerWidth","removeEventListener","undefined","clearTimeout","currentCarouselWrapper","getBoundingClientRect","width","height","position","removeProperty","itemsBox","_a","wrapperBox","_b","snapToItem","carouselChildren","paddingWidth","carouselWidth","processWidth","child","childWidth","offsetWidth","all","Array","from","map","element","hasImages","querySelectorAll","img","complete","onload","onerror","checkIfCardImagesLoaded","newOffset","dir","targetItem","item","viewBox","HTMLElement","offsetLeft","getCenterMoveVal","moveVal","atStart","atEnd","itemsWrapper","maxRight","returnObj","getMoveVal","winTSY","winTSListener","changedTouches","clientY","winTMListener","preventDefault","winTMY","Math","abs","winTEListener","passive","val","transform","checkActiveItem","callback","scrollItems","centerPoint","centerPointBuffer","childRect","left","right","handleMoveInteract","changedIndex","useImperativeHandle","getCurrentIndex","_touchX","x","clientX","_touchDelta","display","alignItems","transition"],"mappings":"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","x_google_ignoreList":[0,3]}